{ self, lib, config, options, pkgs, ... }:

with lib;
with self.lib;
let inherit (self) configDir;
    cfg = config.modules.shell.zsh;
in {
  options.modules.shell.zsh = with types; {
    enable = mkBoolOpt false;

    aliases = mkOpt (attrsOf (either str path)) {};

    rcInit = mkOpt' lines "" ''
      Zsh lines to be written to $XDG_CONFIG_HOME/zsh/extra.zshrc and sourced by
      $XDG_CONFIG_HOME/zsh/.zshrc
    '';
    envInit = mkOpt' lines "" ''
      Zsh lines to be written to $XDG_CONFIG_HOME/zsh/extra.zshenv and sourced
      by $XDG_CONFIG_HOME/zsh/.zshenv
    '';

    rcFiles  = mkOpt (listOf (either str path)) [];
    envFiles = mkOpt (listOf (either str path)) [];
  };

  config = mkIf cfg.enable {
    users.defaultUserShell = pkgs.zsh;

    programs.zsh = {
      enable = true;
      # I init completion myself, because enableGlobalCompInit initializes it
      # too soon, which means commands initialized later in my config won't get
      # completion, and running compinit twice is slow.
      enableCompletion = true;
      enableGlobalCompInit = false;
      # Again. I configure the prompt myself, so disable the default.
      promptInit = "";
    };

    # Some interactive shell utilies I find universally indispensible.
    user.packages = with pkgs; [
      bat
      exa
      fasd
      fd
      fzf
      gnumake
      jq
      libqalculate  # calculator cli w/ currency conversion
      nix-zsh-completions
      ripgrep
      tldr
      unzip
      vim
    ];

    # Ensure XDG compliance
    env.ZDOTDIR = "$XDG_CONFIG_HOME/zsh";

    home.configFile = {
      # Write it recursively so other modules can write files to it
      "zsh" = { source = "${configDir}/zsh"; recursive = true; };

      # Why extra.zsh{rc,env} when I could be using extraInit? Because extraInit
      # generates those files in /etc/profile, and mine just write the files to
      # ~/.config/zsh; where it's easier to edit and tweak them in case of
      # issues or when experimenting. Plus, my zsh dotfiles should be relatively
      # NixOS agnostic, so they can still be deployed elsewhere.
      "zsh/extra.zshrc".text =
        let aliasLines = mapAttrsToList (n: v: "alias ${n}=\"${v}\"") cfg.aliases;
        in ''
           # Clean up DM leftovers, as much as we can. This can only be for
           # non-essential cleanup, as setupCommands only works on some DMs
           # (e.g. LightDM, GDM, and SDDM).
           rm -rf ~/.pki ~/.nv

           # This file was autogenerated, do not edit it!
           ${concatStringsSep "\n" aliasLines}
           ${concatMapStrings (path: "source '${path}'\n") cfg.rcFiles}
           ${cfg.rcInit}
        '';

      "zsh/extra.zshenv".text = ''
        # This file is autogenerated, do not edit it!
        ${concatMapStrings (path: "source '${path}'\n") cfg.envFiles}
        ${cfg.envInit}
      '';
    };

    system.userActivationScripts.cleanupZgen = ''
      rm -rfv "$XDG_CONFIG_HOME/zsh/"*.zwc "$XDG_CACHE_HOME/zsh" $ZGEN_DIR/init.zsh{,.zwc}
    '';
  };
}
