#!/usr/bin/env cached-nix-shell
#! nix-shell -p ruby_3_1 rubyPackages_3_1.thor rubyPackages_3_1.json -i "ruby -S"

require_relative '../lib/hey'

class Hey < HeyCLI
  def help
    puts <<~DESC
      Nix's CLI has a poor user story for NixOS users, in my opinion. I'm
      envious of Guix in this respect, so I wrote this script to abstract  more
      common NixOS workflows, like rebuilding (nixos-rebuild), cleaning up
      (nix-collect-garbage), package/env management (nix-env), updating/rolling
      back, and dotfile management. And I've split out additional subcommands in
      other bin/hey* scripts (like heyops for remote deployment of NixOS
      configs).
    DESC
    puts
    super
  end


  group "Flake management" do
    # TODO: Test me
    desc "install [HOSTNAME]", "Deploy these dotfiles to a system for the first time."
    option :dest,   aliases: :d, type: :string, desc: 'Where to deploy dotfiles after install (default: ~/.config/dotfiles)'
    option :repo,   type: :string, default: "hlissner/dotfiles", desc: "Where to clone your dotfiles flake from"
    option :root,   type: :string, desc: "Mount root", default: "/mnt"
    option :ssh,    aliases: :s, desc: 'Clone from ssh+git instead of https. Ignored if --repo is an URL'
    option :tmpdir, type: :string, default: "#{}", desc: "Where to clone your dotfiles flake from"
    def install *args
      user_error "Must be root to run this command" unless Process.uid == 0
      user_error "No mounted root at #{options[:root]}. Did you mount/partition it?" unless Dir.exists? options[:root]
      @flake.valid!
      dest = File.expand_path(options[:dest] || "#{options[:root]}/home/#{@flake.user}/.config/dotfiles")
      repo = options[:repo]
      if !repo.match /^https?:\/\//
        proto = 'git@github.com:' if options[:ssh] else 'https://github.com/'
        repo = "#{proto}#{options[:repo]}"
      end
      Dir.mktmpdir do |tmpdir|
        puts "Deploying dotfiles..."
        run "nix-shell", "-p", "git", "--run", "git", "clone", repo, tmpdir
        unless Dir.exists? "#{dest}/hosts/#{@flake.host}"
          user_error "No host config for #{@flake.host} in dotfile flake"
        end
        puts "Installing NixOS..."
        run "nix-shell", "-p", "nixFlakes",
            "--run", "nixos-install",
            "--root", options[:root],
            "--flake", @flake.uri
        puts "Moving dotfiles to #{options[:dest]}..."
        unless Dir.exists? dest
          FileUtils.mkdir_p File.expand_path('..', dest)
          FileUtils.mv tmpdir, dest
          FileUtils.chown_R @flake.user, 'users', dest
        end
      end
      puts "Done!"
    end

    desc :pull, "Update flake inputs"
    def pull *inputs
      if inputs.empty?
        puts "Updating all inputs."
        nix :flake, "update", "--impure", @flake.path
      else
        puts "Trying to update inputs: #{inputs.join ' '}"
        nix :flake, "lock", "--impure",
            inputs.map { |i| [ "--update-input", i ] },
            @flake.path
      end
    end

    desc "switch [DIRECTIVE]", "Rebuild your system and, by default, switches to it"
    option :builder, aliases: :b, type: :string, repeatable: true,
           desc: "Remote machine(s) to build the system on"
    option :target,   aliases: :t, type: :string, repeatable: true,
           desc: "Where to deploy the built system"
    option :fast,     type: :boolean, desc: "Rebuild as quickly as possible"
    option :profile,  type: :string,  desc: "What profile to deploy the system to"
    option :rollback, type: :boolean, desc: "Roll back to last active generation"
    option :theme,    type: :string,  desc: "Theme to switch to"
    option :generation, aliases: "-g", type: :numeric,
           desc: "What generation of PROFILE to switch to"
    map "sw" => "switch"
    def switch mode = nil
      options[:fast] ||= mode == "test"
      if options[:generation]
        return run "nix-env",
                   "--switch-generation", Integer(options[:generation]),
                   "--profile", options[:profile] || DEFAULT_PROFILE,
                   sudo: true
      elsif options[:theme]
        @flake.theme = options[:theme]
        options[:fast] = ! mode
      end
      @flake.valid!
      Dir.chdir @flake.path do
        run 'nixos-rebuild', '--impure', '--flake', @flake.uri,
            optarg(:target, flag: "--target-host"),
            optarg(:builder) { |k,v| [ "--builders", v.join(' ; ') ] },
            optarg(:fast, nil),
            optarg(:profile, nil),
            optarg(:verbose, nil),
            optarg(:rollback, nil),
            mode || "switch",
            sudo: !options[:user]
      end
    end

    desc "build OPERATION [HOST]", "TODO"
    option "--print-out-paths", desc: "TODO"
    option :profile, desc: "TODO"
    def build op, host = @flake.host
      if op.match /^vm(-with-bootloader)?$/
        run 'nixos-rebuild', '--impure', '--flake', "#{@flake.path}##{host}",
            "build-#{op}",
            optarg(:verbose, nil),
            sudo: !options[:user]
      else
        path = @flake.path
        case op
        when "iso"
          host = "nixosConfigurations.#{host}.config.system.build.isoImage"
        end
        nix :build, "#{path}##{host}",
            optarg(:profile),
            optarg("--print-out-paths", nil)
      end
    end

    desc :ls, "List all generations of your system profile"
    def ls
      run "nix-env", "--list-generations", "--profile", DEFAULT_PROFILE, sudo: true
    end

    desc "rm GENERATION", "Delete a specific system generation"
    def rm
      run "nix-env", "--delete-generations", "--profile", DEFAULT_PROFILE, *args, sudo: true
    end

    desc "diff FROM TO", "Diff two system generations"
    def diff from, to
      profile = DEFAULT_PROFILE
      if from == to
        puts "Comparing the same profile! Aborting..."
        exit 1
      elsif [from, to].compact.select do |gen|
              File.exists? "#{profile}-#{gen}-link" or
                puts "Generation #{gen} does not exist!"
            end.length != [from, to].compact.length
        exit 2
      end
      from = from ? "#{profile}-#{from}-link" : profile
      to   = to   ? "#{profile}-#{to}-link"   : profile
      fromDevs = `nix-store -q --references #{from}`.split
      toDevs   = `nix-store -q --references #{to}`.split
      puts (fromDevs - toDevs).map { |d| "\e[31m-#{d}\e[0m" }
      puts (toDevs - fromDevs).map { |d| "\e[32m+#{d}\e[0m" }
    end

    desc :rollback, "Rollback to last generation"
    def rollback
      rebuild "switch", "--rollback"
    end

    desc :gc, "Garbage collect & optimize nix store"
    option :all,    aliases: :a, type: :boolean, desc: "GC both the user and system profiles"
    option :system, aliases: :s, type: :boolean, desc: "Only GC the system profile"
    def gc *args
      if options[:all] or options[:system]
        puts "Cleaning up your system profile..."
        run %w{nix-collect-garbage -d}, sudo: true
        run %w{nix-store --optimise}, sudo: true
        # Move away left-over secrets to be deleted later. The
        # switch-to-configuration call below regenerates them, but we must be
        # certain that the process succeeds first.
        if File.exists?("/run/secrets/*")
          run %w{mv /run/secrets /run/secrets.old}
        end
        # nix-collect-garbage is a Nix tool, not a NixOS tool. It won't delete old
        # boot entries until you do a nixos-rebuild (which means we'll always have
        # 2 boot entries at any time). Instead, we properly delete them by
        # reloading the current environment.
        run %w{nix-env --delete-generations old --profile /nix/var/nix/profiles/system}, sudo: true
        run %w{/nix/var/nix/profiles/system/bin/switch-to-configuration switch}, sudo: true
        run %w{rm -rf /run/secrets.old}, sudo: true
      end
      if options[:all] or not options[:system]
        puts "Cleaning up your user profile..."
        run %w{nix-collect-garbage -d}
      end
    end

    desc :check, "Run a flake check on your dotfiles flake"
    map "ch" => "check"
    def check
      user_error "Flake is not derived from hlissner/dotfiles" unless @flake.dotfiles?
      code = nix :flake, "check", "--impure",
                 "--no-warn-dirty",
                 "--no-use-registries",
                 "--no-write-lock-file",
                 "--no-update-lock-file",
                 @flake.path
      puts "Check found no issues" if code.zero?
    end

    desc "info [REPO] [EXPECTED-HASH]", "Dump information about your system flake or a REPO"
    option :type, type: :string, banner: "VCS", default: "git",
           desc: "What VC system to use (default: git)"
    def info repo=nil, rev=nil
      if repo
        repo, commit = repo.split ":"
        repo = "https://github.com/#{repo}" if repo.match /^[^\/]+\/[^\/]+$/
        run "nix-shell", "-p", "nix-prefetch-git",
            "--run", "nix-prefetch-#{options[:type]} --quiet '#{repo}' #{rev}"
      else
        nix :flake, "metadata", "--impure", "--no-warn-dirty", @flake.path
        puts
        nix :flake, "show", "--impure", "--no-warn-dirty", @flake.path
      end
    end
  end


  group "Development Tools" do
    desc :dev, "TODO"
    stop_on_unknown_option! :dev
    def dev *args
      nix :develop, @flake.path, *args
    end

    desc :repl, "Open a REPL with the dotfiles flake (and nixpkgs inputs) preloaded"
    def repl *args
      nix :repl,
          '--extra-experimental-features', 'flakes repl-flake',
          '--expr', <<-NIX
          with builtins;
          let
            pkgs  = (getFlake "flake:nixpkgs").legacyPackages.${currentSystem};
            pkgs' = (getFlake "flake:nixpkgs-unstable").legacyPackages.${currentSystem};
            self  = mapAttrs
              (n: v: if isAttrs v && hasAttr currentSystem v then v.${currentSystem} else v)
                (getFlake "flake:dotfiles");
            self' = getFlake "flake:dotfiles";
          in { inherit pkgs pkgs' self self'; }
        NIX
    end

    # desc :bundle, "TODO"
    # def bundle; end
  end


  group "Package management" do
    desc "search REGEX...", "Search nixpkgs for packages that match REGEX"
    option :expr, type: :string, desc: "Interpret installables as attribute paths relative to the Nix expression EXPR"
    option :file, type: :string, desc: "Interpret installables as attribute paths relative to the Nix expression stored in FILE (or read from stdin if - is given)"
    map "s" => "search"
    def search *args
      nix :search,
          '--no-update-lock-file',
          @flake.explicit? ? 'nixpkgs' : @flake.path,
          optarg(:expr),
          optarg(:file),
          # Interpret '!REGEX' as '-e REGEX'
          args.map { |a| a.match(/^!/) ? [ "-e", a[1..] ] : a.delete_prefix("\\") }.flatten
    end
  end


  group "Dotfile management" do
    desc "swap PATH...", <<~EOF
      Recursively swap nix-store symlinks with copies (or back)

      The purpose is so you can have copies of your dotfiles that can be
      modified in place (so you can iterate on them quickly instead of 'hey
      re'ing between changes). Run again to restore the old link(s).

      Warning: backup your copies, or they will be destroyed when restored!
    EOF
    option :force, aliases: '-f', type: :boolean, desc: "Overwrite any pre-existing files"
    def swap *args
      for target in args
        if File.directory? target
          files = Dir.glob("#{target}/**/*.nix-store-backup")
          if files.length > 0
            puts "There are swapped files here. Unswapping!"
            swap *files
          else
            puts "Swapping files in #{target}"
            swap *(Dir.glob("#{target}/**/*")
                     .select { |f| File.symlink? f }
                     .select { |l| File.readlink(l).match '^/nix/store/' })
          end
        elsif File.file? "#{target}.nix-store-backup"
          puts "Unswapping #{target}"
          run :mv, optarg(:force, "-f"), '-i', "#{target}.nix-store-backup", target
        elsif File.file? target
          puts "Swapping #{target}"
          run :mv, optarg(:force, "-f"), target, "#{target}.nix-store-backup"
          run :cp, optarg(:force, "-f"), "#{target}.nix-store-backup", target
          run :chmod, "u+rw", target
        else
          user_error "Not a valid target: #{target}"
        end
      end
    end
  end
end

load './hey-ops'

Hey.start ARGV
